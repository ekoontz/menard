{
 "achieve" [{ :sem {:pred :achieve}}]
 "ask" [{ :sem {:pred :ask}}]
 "avoid" [{ :sem {:pred :avoid}}]
 "be" (let [exceptions [{:infl :present :agr {:person :1st :number :sing} :surface "am"}
                        {:infl :present :agr {:person :3rd :number :sing} :surface "is"}
                        {:infl :present :surface "are"}
                        {:infl :past-simple :agr {:number :plur} :surface "were"}
                        {:infl :past-simple :agr {:person :2nd} :surface "were"}
                        {:infl :past-simple :surface "was"}
                        {:infl :past-participle :surface "been"}]
            ;; the 3 possible subcategorizations for "be":
            ;; 1. "I am"
            subject-only {:1 {:cat :noun}
                          :2 []}

            ;; 2. "I am a student"
            subject-object-noun
            (let [number (atom :top)]
              {:1 {:cat :noun
                   :agr {:number number}}
               :2 {:cat :noun
                   :subcat []
                   :agr {:number number}}
               :3 []})

            ;; 3. "I am sure"
            subject-adjective {:1 {:cat :noun}
                               :2 {:cat :adjective}
                               :3 []}]
        [{:sem {:pred :be}
          :subcat subject-only
          :exceptions exceptions}
         {:sem {:pred :be}
          :subcat subject-object-noun
          :exceptions exceptions}
         {:reflexive false
          :sem {:pred :be}
          :subcat subject-adjective
          :exceptions exceptions}
         { ;; "is sleeping"
          :derivation {:sense 4}
          :aux true
          :infl :present
          :sem {:tense :present
                :aspect :progressive}
          :subcat {:2 {:infl :gerund}}
          :exceptions exceptions}
         { ;; "is" (aux sense)
          :derivation {:sense 5}
          :aux true
          :infl :present
          :sem {:tense :present
                :aspect :progressive
                :obj :anaphor}
          :subcat {:2 []}
          :exceptions exceptions}
         { ;; "was sleeping"
          :derivation {:sense 6}
          :aux true
          :infl :past-simple
          :sem {:tense :past
                :aspect :progressive}
          :subcat {:2 {:infl :gerund}}
          :exceptions exceptions}
         { ;; "was" (aux sense)
          :derivation {:sense 7}
          :aux true
          :infl :past-simple
          :sem {:tense :past
                :aspect :progressive
                :obj :anaphor}
          :subcat {:2 []}
          :exceptions exceptions}])

 "become" (let [exceptions [{:infl :past-simple
                             :surface "became"}
                            {:infl :past-participle
                             :surface "become"}]]
           [{ :sem {:pred :become}
             :exceptions exceptions}])

 "begin" (let [exceptions [{:infl :past-simple
                            :surface "began"}
                           {:infl :past-participle
                            :surface "begun"}]]
          [{ :sem {:pred :begin}
            :exceptions exceptions}])

 "believe" [{:sense 1
             :sem {:pred :believe}}

            {:sense 2
             :sem {:pred :believe}
             :subcat {:2 {:cat :verb
                          :rule "s"}}}

            {:sense 3
             :sem {:pred :believe}
             :subcat {:2 {:cat :comp
                          :rule "comp2"}}}]

 "bubble" [{:sem {:pred :bubble}}]
 
 "call" [{ :sem {:pred :call}}]

 "can" [{:modal :base
         :sem {:pred :be-able-to}
         :exceptions [{:infl :present
                       :surface "can"}
                      {:infl :past-simple
                       :surface "could"}]}]

 "cause" [{:sem {:pred :cause}}]
 
 "come" (let [exceptions [{:infl :past-simple
                           :surface "came"}
                          {:infl :past-participle
                           :surface "come"}]]
          [{:sem {:pred :come} :subcat {:2 []}
            :exceptions exceptions}])
 
 "design" [{:sem {:pred :design}}]

 "do" (let [exceptions [{:infl :past-simple :surface "did"}
                        {:infl :past-participle :surface "done"}]
            agr (atom :top)]
        [{;; "I do", "I did"
          :exceptions exceptions
          :derivation {:sense 1}
           :sem {:pred :do}}
         
         ;; "do you sleep?", "does he sleep?"
         {:agr agr
          :exceptions exceptions
          
          :aux true
          :infl :present
          :derivation {:sense 2}
          :sem {:aspect :habitual
                :tense :present
                :mood :interog}
          :subcat {:1 {:cat :verb
                       :aux false
                       :agr agr
                       :rule "s-comp"
                       :phrasal true
                       :sem {:mood :decl}
                       :subcat []
                       :infl :base}
                   :2 []}}

         ;; "did you sleep?"
         (let [sem (atom {:tense :past
                          :mood :interog})]
           {:agr agr
            :exceptions exceptions
            
            :aux true
            :infl :past-simple
            :derivation {:sense 3}
            :sem sem
            :subcat {:1 {:cat :verb
                         :aux false
                         :agr agr
                         :rule "s-comp"
                         :phrasal true
                         :sem sem
                         :subcat []
                         :infl :base}
                     :2 []}})

         ;; "what did she see?"
         (let [sem (atom {:tense :past
                          :mood :interog
                          :aspect :progressive})]
           {:agr agr
            :exceptions exceptions
            
            :reflexive false
            :aux true
            :infl :past-simple
            :derivation {:sense 4}
            :sem sem
            :subcat {:1 {:cat :verb
                         :slash true
                         :aux false
                         :agr agr
                         :phrasal true
                         :sem sem
                         :subcat {:1 {:wh-word true}
                                  :2 []}
                         :infl :base}
                     :2 []}})
         ;; "what does she see?"
         (let [sem (atom {:tense :present
                          :mood :interog
                          :aspect :progressive})]
           {:agr agr
            :exceptions exceptions
            
            :reflexive false
            :aux true
            :infl :present
            :derivation {:sense 5}
            :sem sem
            :subcat {:1 {:cat :verb
                         :slash true
                         :aux false
                         :agr agr
                         :phrasal true
                         :sem sem
                         :subcat {:1 {:wh-word true}
                                  :2 []}
                         :infl :base}
                     :2 []}})])
 
 "eat" (let [exceptions [{:infl :past-simple :surface "ate"}
                         {:infl :past-participle :surface "eaten"}]]
         [{:exceptions exceptions  :sem {:pred :eat}}])
 "emigrate" [{:sem {:pred :emigrate}}]
 "explain" [{ :sem {:pred :explain}}]

 "feed" [{:sem {:pred :feed}
          :exceptions [{:infl :past-simple
                        :surface "fed"}
                       {:infl :past-participle
                        :surface "fed"}]}]

 "feel" (let [exceptions [{:infl :past-simple :surface "felt"}
                          {:infl :past-participle :surface "felt"}]]
           [{:exceptions exceptions  :sem {:pred :feel}}])
 "find" (let [exceptions [{:infl :past-simple :surface "found"}
                          {:infl :past-participle :surface "found"}]]
          [{:exceptions exceptions  :sem {:pred :find}}])
 "get" (let [exceptions [{:infl :past-simple :surface "got"}
                         {:infl :past-participle :surface "got"}]]
         [{:exceptions exceptions  :sem {:pred :get}}])

 "give" (let [exceptions [{:infl :past-simple :surface "gave"}
                          {:infl :past-participle :surface "given"}]]
          [{:exceptions exceptions
            :subcat {:2 {:cat :prep
                         :sem {:pred :to}}
                     :3 {:cat :noun}}
            
            :sem {:pred :give}}])
 "go"
 (let [exceptions [{:infl :past-simple :surface "went"}
                   {:infl :past-participle :surface "gone"}]]
   [{:exceptions exceptions
      :sem {:pred :go}
     :subcat {:2 []}}
    {:exceptions exceptions
      :sem {:pred :go}
     :subcat {:2 {:cat :prep
                  :sem {:pred :to}}
              :3 []}}])
 "have" (let [;; TODO: factor out commonalities in agreement into a new variable called 'agr-exceptions' and then
              ;; multiply by aux-exceptions and non-aux-exceptions.
              aux-exceptions [{:agr {:person :1st} :surface "have" :infl :present
                               :sem {:tense :past
                                     :aspect :perfect}}
                              {:agr {:person :2nd} :surface "have" :infl :present
                               :sem {:tense :past
                                     :aspect :perfect}}
                              {:agr {:person :3rd :number :sing} :surface "has"
                               :infl :present
                               :sem {:tense :past
                                     :aspect :perfect}}
                              {:agr {:person :3rd :number :plur} :surface "have"
                               :infl :present
                               :sem {:tense :past
                                     :aspect :perfect}}
                              {:surface "had"
                               :infl :past-simple
                               :sem {:tense :past
                                     :aspect :pluperfect}}
                              {:surface "had"
                               :infl :past-participle}]
              non-aux-exceptions [{:infl :present :agr {:person :1st} :surface "have"}
                                  {:infl :present :agr {:person :2nd} :surface "have"}
                                  {:infl :present
                                   :agr {:person :3rd :number :sing} :surface "has"}
                                  {:infl :present :agr {:person :3rd :number :plur} :surface "have"}
                                  {:infl :past-simple :surface "had"}
                                  {:infl :past-participle :surface "had"}]]
          [{
            ;; {:aux false} not needed because of rule: aux-default-is-false,
            ;; but made explicit for contrast with aux=true senses below of this verb.
            :aux false
            :derivation {:sense 1}
            :sem {:pred :have}
            :exceptions non-aux-exceptions}
           {
            :aux true
            :derivation {:sense 2}
            :sem {:tense :past
                  :obj :anaphor
                  :aspect :perfect}
            :subcat {:2 []}
            :exceptions aux-exceptions}
           {
            :aux true
            :derivation {:sense 3}
            :sem {:tense :past
                  :aspect :perfect}
            :subcat {:2 {:infl :past-participle}}
            :exceptions aux-exceptions}
           {
            :aux true
            :derivation {:sense 4}
            :sem {:tense :past
                  :obj :anaphor
                  :aspect :pluperfect}
            :subcat {:2 []}
            :exceptions aux-exceptions}
           {
            :aux true
            :derivation {:sense 5}
            :sem {:tense :past
                  :aspect :pluperfect}
            :subcat {:2 {:infl :past-participle}}
            :exceptions aux-exceptions}])

 "hear" (let [exceptions [{:infl :past-simple :surface "heard"}
                          {:infl :past-participle :surface "heard"}]]
          [{:exceptions exceptions  :sem {:pred :hear}}])
 "help" [{ :sem {:pred :help} :subcat {:1 :top :2 :top}}]

 "hope" [{:sense 1
          
          :sem {:pred :hope}
          :subcat {:1 {:top :top}
                   :2 []}}

         {:sense 2
          
          :sem {:pred :hope}
          :subcat {:2 {:cat :verb
                       :rule "s"}}}
          
         {:sense 3
          
          :sem {:pred :hope}
          :subcat {:2 {:cat :comp
                       :rule "comp2"}}}]

 "inhibit" [{ :sem {:pred :inhibit}}]

 "keep" (let [exceptions [{:infl :past-simple :surface "kept"}
                          {:infl :past-participle :surface "kept"}]]
           [{:exceptions exceptions  :sem {:pred :keep}}])
 "know" (let [exceptions [{:infl :past-simple :surface "knew"}
                          {:infl :past-participle :surface "known"}]]
          [{:exceptions exceptions
            
            :sem {:pred :know}

            {:sense 2
             
             :exceptions exceptions
             :sem {:pred :know}
             :subcat {:2 {:cat :verb
                          :rule "s"}}}

            {:sense 3
             
             :exceptions exceptions
             :sem {:pred :know}
             :subcat {:2 {:cat :comp
                          :rule "comp2"}}}}])
 
 "leave" (let [exceptions [{:infl :past-simple :surface "left"}
                           {:infl :past-participle :surface "left"}]]
           [{:exceptions exceptions  :sem {:pred :leave}}])
 "let" (let [exceptions [{:infl :past-simple :surface "let"}
                         {:infl :past-participle :surface "let"}]]
          [{:exceptions exceptions  :sem {:pred :let}}])
 "like" [{ :sem {:pred :like}}]
 "live" [{ :sem {:pred :live}}]
 "look" [{ :sem {:pred :look}
          :subcat {:1 :top :2 []}}
         { :sem {:pred :look}
          :subcat {:1 :top
                   :2 {:cat :prep
                       :sem {:pred :at}}
                   :3 []}}]
 "make" (let [exceptions [{:infl :past-simple :surface "made"}
                          {:infl :past-participle :surface "made"}]]
           [{:exceptions exceptions  :sem {:pred :make}}])
 "mean" (let [exceptions [{:infl :past-simple :surface "meant"}
                          {:infl :past-participle :surface "meant"}]]
          [{:exceptions exceptions  :sem {:pred :mean}}])
 "move" [{ :sem {:pred :move} :subcat {:1 :top :2 :top}}]

 "must" [{:modal :base
          
          :inflected? true
          :sem {:pred :must}}]
 "overcome" (let [exceptions [{:infl :past-simple :surface "overcame"}
                              {:infl :past-participle :surface "overcame"}]]
              [{
                :exceptions exceptions
                :sem {:pred :overcome}}])
 "need" [;; need to leave
         {:sense 1
          :sem {:pred :need}
          :modal :infinitive}
         ;; need some money
         {:sense 2
          :sem {:pred :need}
          :modal :false
          :subcat {:1 {:cat :noun} 
                   :2 {:cat :noun :subcat []}
                   :3 []}}]
              
 "perform" [{ :sem {:pred :perform}}]
 "play" [{ :sem {:pred :play}}]
 "prevent" [{ :sem {:pred :prevent}}]
 "put" (let [exceptions [{:infl :past-simple :surface "put"}
                         {:infl :past-participle :surface "put"}]]
         [{:exceptions exceptions
           :subcat {:2 {:cat :prep
                        :sem {:pred :on}}
                    :3 {:cat :noun}}
           
           :sem {:pred :put-on}}
          {:exceptions exceptions
           :subcat {:2 {:cat :prep
                        :sem {:pred :in}}
                    :3 {:cat :noun}}
           
           :sem {:pred :put-in}}])
 "read" (let [exceptions [{:infl :past-simple :surface "read" :note ["past"]}
                          {:infl :past-participle :surface "read" :note ["past"]}]]
          [{:exceptions exceptions  :sem {:pred :read}}])
 "ruin" [{:sem {:pred :ruin}
          :subcat {:2 {:cat :noun}}}]

 "run" (let [exceptions [{:infl :past-simple :surface "ran"}
                         {:infl :past-participle :surface "run"}]]
          [{:exceptions exceptions  :sem {:pred :run}}])
 "say" (let [exceptions [{:infl :past-simple :surface "said"}
                         {:infl :past-participle :surface "said"}]]
         [{:exceptions exceptions
           :sense 1
           
           :sem {:pred :say}}
           
          {:exceptions exceptions
           :sense 2
           
           :sem {:pred :say}
           :subcat {:2 {:cat :verb
                        :rule "s"}}}
           
          {:exceptions exceptions
           :sense 3
           
           :sem {:pred :say}
           :subcat {:2 {:cat :comp
                        :rule "comp2"}}}])
 
 "see" (let [exceptions [{:infl :past-simple :surface "saw"}
                         {:infl :past-participle :surface "seen"}]]
         [{:exceptions exceptions
           :sem {:pred :see}}])
 "seem" [{ :sem {:pred :seem} :subcat {:1 :top :2 :top}}]
 "show" [{ :sem {:pred :show} :subcat {:1 :top :2 :top}}]
 "sing" [{:sem {:pred :sing}
          :exceptions [{:infl :past-simple
                        :surface "sang"}
                       {:infl :past-participle
                        :surface "sung"}]}]

 "sit" (let [exceptions [{:infl :past-simple :surface "sat"}
                         {:infl :past-participle :surface "sat"}]]
         [{:exceptions exceptions
           
           :sem {:pred :sit}
           :subcat {:1 :top :2 []}}])

 "sleep" (let [exceptions [{:infl :past-simple :surface "slept"}
                           {:infl :past-participle :surface "slept"}]]
           [{:exceptions exceptions
             
             :sem {:pred :sleep
                   :subj {:prop {:animate true}}} ;; TODO: move to encyclopedia.
             :subcat {:1 :top :2 []}}])
 "start" [{ :sem {:pred :start} :subcat {:1 :top :2 :top}}]
 "take" (let [exceptions [{:infl :past-simple :surface "took"}
                          {:infl :past-participle :surface "taken"}]]
          [{ :sem {:pred :take}
            :exceptions exceptions}])
 "talk" [{
          :sem {:pred :talk}
          :subcat {:1 :top
                   :2 []}}
         {
          :sem {:pred :talk}
          :subcat {:1 :top
                   :2 {:cat :prep
                       :sem {:pred :to}}
                   :3 []}}]
 "teach" (let [exceptions [{:infl :past-simple :surface "taught"}
                           {:infl :past-participle :surface "taught"}]]
           [{:exceptions exceptions  :sem {:pred :teach}}])
 "tell" (let [exceptions [{:infl :past-simple :surface "told"}
                          {:infl :past-participle :surface "told"}]]
          [{:exceptions exceptions
             :sem {:pred :tell}}])
 "think" (let [exceptions [{:infl :past-simple :surface "thought"}
                           {:infl :past-participle :surface "thought"}]]
           [{:sense 1
             :exceptions exceptions
             
             :sem {:pred :think}
             :subcat {:1 :top :2 []}}

            ;; "think that you will see the cat"
            {:sense 2
             :exceptions exceptions
             
             :sem {:pred :think}
             :subcat {:2 {:cat :verb
                          :rule "s"}}}

            ;; "think that you will see the cat"
            {:sense 3
             :exceptions exceptions
             
             :sem {:pred :think}
             :subcat {:2 {:cat :comp
                          :rule "comp2"}}}])

            ;; TODO: "the cat they think that you will see"
 
 "to" ;; "to sleep"
 [(let [sem (atom :top)
        agr (atom :top)
        reflexive? (atom :top)]
    {
     :agr agr
     :reflexive reflexive?
     :normal-transitive-defaults? false
     :inflected? true
     :infl :infinitive
     :sem sem
     :subcat {:1 {:cat :verb
                  :modal false
                  :agr agr
                  :reflexive reflexive?
                  :subcat {:1 {:cat :noun}} ;; prevent "[vp:inf to to]"
                  :infl :base
                  :sem sem}
              :2 []}})]

 "try" [{
         :sem {:pred :try}
         :modal :infinitive}]
 "turn" [{ :sem {:pred :turn}}]
 "use" [{ :sem {:pred :use}}]
 "walk" [{ :sem {:pred :walk}}]
 "want" [{
          :sem {:pred :want}
          :modal :infinitive}]
 ;; TODO: using "will" as an example of using
 ;; a single lexeme and deriving all 4 aux-senses:
 ;; {intrans,trans} x {decl,interog} = {intrans + decl, intrans + interog, trans + decl, trans + interog}
 "will" [{:aux true
          
          :infl :present
          :inflected? true
          :sem {:tense :future}
          :subcat {:2 {:cat :verb
                       :infl :base}}}]
 
 "would" (let [common {:aux true
                       
                       :infl :present
                       :inflected? true
                       :sem {:tense :conditional}}]
           (map #(dag_unify.core/unify % common)
                [{:derivation {:sense 1}
                  :sem {:obj :unspec}
                  :subcat {:2 []}}
                 {:derivation {:sense 2}           
                  :subcat {:2 {:cat :verb
                               :infl :base}}}
                 ;; TODO: be, can, do, may, should, will, would: all these
                 ;; can be the X in "[s-interog +X .[s-comp .noun +verb]]":
                 ;; generalize with a lexical rule. See above related TODO about "will".
                 (let [sem (atom {:tense :condition})]
                   {:derivation {:sense 3}
                    :sem sem
                    :subcat {:1 {:cat :verb
                                 :aux false
                                 :sem sem
                                 :subcat []
                                 :infl :base}
                              :2 []}})]))

 "work" [{ :sem {:pred :work}}]}
